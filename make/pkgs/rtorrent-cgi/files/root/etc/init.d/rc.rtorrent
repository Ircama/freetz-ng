#!/bin/sh

DAEMON=rtorrent
DAEMON_BIN=rtorrent
PID_FILE=/var/run/$DAEMON.pid
. /etc/init.d/modlibrc

# Auto-detect first available USB storage
autodetect_storage() {
	# Load Freetz config if available
	[ -r /mod/etc/conf/mod.cfg ] && . /mod/etc/conf/mod.cfg
	local stor_prefix="${MOD_STOR_PREFIX:-uStor}"
	
	# Try ${stor_prefix}01 first (most common)
	if [ -d "/var/media/ftp/${stor_prefix}01" ]; then
		echo "/var/media/ftp/${stor_prefix}01/rtorrent"
		return 0
	fi
	
	# Try to find any mounted USB storage
	local first_usb="$(find /var/media/ftp -mindepth 1 -maxdepth 1 -type d 2>/dev/null | head -n1)"
	if [ -n "$first_usb" ]; then
		echo "$first_usb/rtorrent"
		return 0
	fi
	
	# Fallback to tmpfs (will be lost on reboot!)
	echo "/var/tmp/rtorrent"
}

USERNAME=bittorrent
GROUPNAME=users

echoFailedAndExit() {
	echo 'failed.'
	[ -n "$1" ] && exit $1 || exit 1
}

checkNotEmpty() {
	if [ -z "$1" ]; then
		[ -n "$2" ] && echo -e "\n$2 must not be empty."
		echoFailedAndExit 255
	fi
}

checkDirectoryExists() {
	if [ ! -d "$1" ]; then
		echo -e "\nCreating directory '$1'."
		mkdir -p "$1" || echoFailedAndExit 255
	fi
}

trim() {
	echo "$1" | sed 's|^[ ]*||;s|[ ]*$||'
}

generate_rtorrent_rc() {
	local RTORRENT_RC="$1"
	
	cat > "$RTORRENT_RC" << EOF
# rTorrent configuration - auto-generated by Freetz-NG
# Do not edit manually - use the web interface

# Directories
directory.default.set = $DOWNLOADDIR
session.path.set = $SESSIONDIR

# Watch directory for new torrents
schedule2 = watch_directory,5,5,"load.start=$WATCHDIR/*.torrent"

# Networking
network.port_range.set = ${RTORRENT_PEERPORT}-${RTORRENT_PEERPORT}
network.port_random.set = no

# Connection limits
throttle.max_peers.normal.set = $RTORRENT_PEERLIMIT
throttle.max_uploads.set = $RTORRENT_UPLOADSLOTS
throttle.max_downloads.set = $RTORRENT_DOWNLOADSLOTS

# Bandwidth limits (0 = unlimited)
throttle.global_down.max_rate.set_kb = $RTORRENT_DOWNLOADRATE
throttle.global_up.max_rate.set_kb = $RTORRENT_UPLOADRATE

# Encryption
protocol.encryption.set = $RTORRENT_ENCRYPTION

# Daemon mode (background vs interactive)
system.daemon.set = $([ "$RTORRENT_DAEMON_MODE" = "yes" ] && echo "true" || echo "false")

# DHT (only if configured by user)
EOF
	if [ -n "$RTORRENT_DHT" ]; then
		cat >> "$RTORRENT_RC" << EOF
dht.mode.set = $RTORRENT_DHT
EOF
	fi

	if [ -n "$RTORRENT_DHTPORT" ]; then
		cat >> "$RTORRENT_RC" << EOF
dht.override_port.set = $RTORRENT_DHTPORT
EOF
	fi

	cat >> "$RTORRENT_RC" << EOF

# PEX (Peer Exchange)
protocol.pex.set = $([ "$RTORRENT_PEX" = "yes" ] && echo "yes" || echo "no")

# SCGI for ruTorrent - UNIX socket or TCP port
EOF
	if [ "$SCGI_MODE" = "port" ]; then
		cat >> "$RTORRENT_RC" << EOF
network.scgi.open_port = $SCGI_HOST:$SCGI_PORT
EOF
	else
		cat >> "$RTORRENT_RC" << EOF
network.scgi.open_local = $SCGI_SOCKET
EOF
	fi

	cat >> "$RTORRENT_RC" << EOF

# Hash checking
pieces.hash.on_completion.set = $([ "$RTORRENT_CHECKHASH" = "yes" ] && echo "yes" || echo "no")

# Pre-allocation
system.file.allocate.set = $([ "$RTORRENT_PREALLOCATE" = "yes" ] && echo "yes" || echo "no")

# Advanced settings (optional)
$([ -n "$RTORRENT_PORT_RANGE" ] && echo "network.port_range.set = $RTORRENT_PORT_RANGE")
$([ -n "$RTORRENT_MAX_MEMORY" ] && echo "pieces.memory.max.set = ${RTORRENT_MAX_MEMORY}M")
$([ -n "$RTORRENT_MAX_OPEN_FILES" ] && echo "network.max_open_files.set = $RTORRENT_MAX_OPEN_FILES")
$([ -n "$RTORRENT_MIN_PEERS" ] && echo "throttle.min_peers.normal.set = $RTORRENT_MIN_PEERS")
$([ -n "$RTORRENT_MAX_PEERS" ] && echo "throttle.max_peers.normal.set = $RTORRENT_MAX_PEERS")
$([ -n "$RTORRENT_MIN_PEERS_SEED" ] && echo "throttle.min_peers.seed.set = $RTORRENT_MIN_PEERS_SEED")
$([ -n "$RTORRENT_MAX_PEERS_SEED" ] && echo "throttle.max_peers.seed.set = $RTORRENT_MAX_PEERS_SEED")
$([ -n "$RTORRENT_BIND_ADDRESS" ] && echo "network.bind_address.set = $RTORRENT_BIND_ADDRESS")

# Encoding
encoding.add = UTF-8
EOF
}

start() {
	echo -n 'Starting rTorrent daemon ... '
	[ -r /etc/options.cfg ] && . /etc/options.cfg

	RTORRENT_BASEDIR=$(trim "$RTORRENT_BASEDIR")
	RTORRENT_SESSIONDIR=$(trim "$RTORRENT_SESSIONDIR")
	RTORRENT_DOWNLOADDIR=$(trim "$RTORRENT_DOWNLOADDIR")
	RTORRENT_WATCHDIR=$(trim "$RTORRENT_WATCHDIR")

	# Strip trailing slashes from BASEDIR to prevent double slashes
	RTORRENT_BASEDIR="${RTORRENT_BASEDIR%/}"

	# Auto-detect storage if BASEDIR is empty
	if [ -z "$RTORRENT_BASEDIR" ]; then
		RTORRENT_BASEDIR="$(autodetect_storage)"
		echo -n "(auto: $RTORRENT_BASEDIR) "
	fi

	checkNotEmpty "$RTORRENT_BASEDIR" 'RTORRENT_BASEDIR'
	if [ "${RTORRENT_BASEDIR:0:1}" != "/" ]; then
		echo -e "\nRTORRENT_BASEDIR must be an absolute path."
		echoFailedAndExit 255
	fi
	checkDirectoryExists "$RTORRENT_BASEDIR"

	# Build full paths
	[ "${RTORRENT_SESSIONDIR:0:1}" = "/" ] && SESSIONDIR="$RTORRENT_SESSIONDIR" || SESSIONDIR="$RTORRENT_BASEDIR/$RTORRENT_SESSIONDIR"
	[ "${RTORRENT_DOWNLOADDIR:0:1}" = "/" ] && DOWNLOADDIR="$RTORRENT_DOWNLOADDIR" || DOWNLOADDIR="$RTORRENT_BASEDIR/$RTORRENT_DOWNLOADDIR"
	[ "${RTORRENT_WATCHDIR:0:1}" = "/" ] && WATCHDIR="$RTORRENT_WATCHDIR" || WATCHDIR="$RTORRENT_BASEDIR/$RTORRENT_WATCHDIR"
	
	# SCGI configuration - UNIX socket or TCP port
	SCGI_MODE="${RTORRENT_SCGI_MODE:-socket}"
	if [ "$SCGI_MODE" = "port" ]; then
		# TCP mode
		SCGI_HOST="${RTORRENT_SCGI_HOST:-127.0.0.1}"
		SCGI_PORT="${RTORRENT_SCGI_PORT:-5000}"
		SCGI_SOCKET=""  # Not used in TCP mode
	else
		# UNIX socket mode - must be on UNIX filesystem
		if [ -z "$RTORRENT_SCGI_SOCKET" ]; then
			SCGI_SOCKET="/tmp/rtorrent-rpc.socket"
		elif [ "${RTORRENT_SCGI_SOCKET:0:1}" = "/" ]; then
			SCGI_SOCKET="$RTORRENT_SCGI_SOCKET"
		else
			# Relative path - use /tmp/
			SCGI_SOCKET="/tmp/$RTORRENT_SCGI_SOCKET"
		fi
		SCGI_HOST=""  # Not used in socket mode
		SCGI_PORT=""  # Not used in socket mode
	fi

	checkDirectoryExists "$SESSIONDIR"
	checkDirectoryExists "$DOWNLOADDIR"
	checkDirectoryExists "$WATCHDIR"

	chown -R $USERNAME:$GROUPNAME "$RTORRENT_BASEDIR"

	# Generate .rtorrent.rc
	RTORRENT_RC="$RTORRENT_BASEDIR/.rtorrent.rc"
	generate_rtorrent_rc "$RTORRENT_RC"
	chown $USERNAME:$GROUPNAME "$RTORRENT_RC"

	# Start rtorrent with -n (skip auto-load rtorrent.rc) and -o import= to load specific config
	# start-stop-daemon with -b puts it in background
	# Redirect stdin/stdout/stderr to prevent "Error opening terminal" issue
	
	# Build command line options
	RTORRENT_OPTS="-n -o import=\"$RTORRENT_RC\""
	[ -n "$RTORRENT_BIND_ADDRESS" ] && RTORRENT_OPTS="$RTORRENT_OPTS -b $RTORRENT_BIND_ADDRESS"
	[ -n "$RTORRENT_TRACKER_IP" ] && RTORRENT_OPTS="$RTORRENT_OPTS -i $RTORRENT_TRACKER_IP"
	
	start-stop-daemon -S -b -m -p "$PID_FILE" \
		-N "$RTORRENT_NICE" \
		-c "$USERNAME:$GROUPNAME" \
		-d "$RTORRENT_BASEDIR" \
		-- /bin/sh -c "exec /usr/bin/rtorrent $RTORRENT_OPTS </dev/null >/dev/null 2>&1"

	exitval=$?
	if [ "$exitval" -eq 0 ]; then
		# Wait for rtorrent to start and create socket
		sleep 2
		# Fix socket permissions after creation
		if [ -S "$SCGI_SOCKET" ]; then
			chmod 0770 "$SCGI_SOCKET" 2>/dev/null
			chgrp users "$SCGI_SOCKET" 2>/dev/null
			echo 'done.'
		else
			# Wait a bit more for socket
			sleep 3
			if [ -S "$SCGI_SOCKET" ]; then
				chmod 0770 "$SCGI_SOCKET" 2>/dev/null
				chgrp users "$SCGI_SOCKET" 2>/dev/null
				echo 'done.'
			else
				echo 'done (socket may take a moment to appear).'
			fi
		fi
	else
		echoFailedAndExit "$exitval"
	fi
}

stop() {
	echo -n 'Stopping rTorrent daemon ... '
	
	# Use start-stop-daemon to stop the process
	start-stop-daemon -K -p "$PID_FILE" -s TERM -R 10
	
	# Clean up socket and PID file
	[ -r /etc/options.cfg ] && . /etc/options.cfg
	RTORRENT_BASEDIR=$(trim "$RTORRENT_BASEDIR")
	if [ -z "$RTORRENT_BASEDIR" ]; then
		RTORRENT_BASEDIR="$(autodetect_storage)"
	fi
	[ "${RTORRENT_SCGI_SOCKET:0:1}" = "/" ] && SCGI_SOCKET="$RTORRENT_SCGI_SOCKET" || SCGI_SOCKET="$RTORRENT_BASEDIR/$RTORRENT_SCGI_SOCKET"
	rm -f "$SCGI_SOCKET" 2>/dev/null
	rm -f "$PID_FILE" 2>/dev/null
	
	echo 'done.'
}

# Override modlibrc's stop_post to avoid spurious "failed" message
# modlibrc's default stop_post does kill -0 check which fails after successful stop
stop_post() {
	return 0
}

case $1 in
	""|load)
		modlib_add_user_and_group $USERNAME $GROUPNAME
		modreg cgi 'rtorrent' 'rTorrent'
		modreg daemon $DAEMON

		modlib_start $RTORRENT_ENABLED
		;;
	unload)
		modunreg daemon $DAEMON
		modunreg cgi 'rtorrent'
		modlib_stop
		;;
	start)
		modlib_start
		;;
	stop)
		modlib_stop
		;;
	restart)
		modlib_restart
		;;
	reload)
		# Regenerate .rtorrent.rc with new settings
		[ -r /etc/options.cfg ] && . /etc/options.cfg
		RTORRENT_BASEDIR=$(trim "$RTORRENT_BASEDIR")
		# Strip trailing slashes
		RTORRENT_BASEDIR="${RTORRENT_BASEDIR%/}"
		if [ -z "$RTORRENT_BASEDIR" ]; then
			RTORRENT_BASEDIR="$(autodetect_storage)"
		fi
		if [ -n "$RTORRENT_BASEDIR" ] && [ -d "$RTORRENT_BASEDIR" ]; then
			# Build full paths (same logic as start)
			[ "${RTORRENT_SESSIONDIR:0:1}" = "/" ] && SESSIONDIR="$RTORRENT_SESSIONDIR" || SESSIONDIR="$RTORRENT_BASEDIR/$RTORRENT_SESSIONDIR"
			[ "${RTORRENT_DOWNLOADDIR:0:1}" = "/" ] && DOWNLOADDIR="$RTORRENT_DOWNLOADDIR" || DOWNLOADDIR="$RTORRENT_BASEDIR/$RTORRENT_DOWNLOADDIR"
			[ "${RTORRENT_WATCHDIR:0:1}" = "/" ] && WATCHDIR="$RTORRENT_WATCHDIR" || WATCHDIR="$RTORRENT_BASEDIR/$RTORRENT_WATCHDIR"
			
			# SCGI socket - must be on UNIX filesystem (use absolute path like /tmp/rtorrent-rpc.socket)
			if [ -z "$RTORRENT_SCGI_SOCKET" ]; then
				SCGI_SOCKET="/tmp/rtorrent-rpc.socket"
			elif [ "${RTORRENT_SCGI_SOCKET:0:1}" = "/" ]; then
				SCGI_SOCKET="$RTORRENT_SCGI_SOCKET"
			else
				# Relative path - use /tmp/
				SCGI_SOCKET="/tmp/$RTORRENT_SCGI_SOCKET"
			fi
			
			# Regenerate config
			RTORRENT_RC="$RTORRENT_BASEDIR/.rtorrent.rc"
			generate_rtorrent_rc "$RTORRENT_RC"
			chown $USERNAME:$GROUPNAME "$RTORRENT_RC"
			
			# Update ruTorrent config to point to correct .rtorrent.rc location
			if [ -f /usr/mww/rutorrent/conf/freetz_config.php ]; then
				sed -i "s|^\\$basedir = .*|\\$basedir = '$RTORRENT_BASEDIR';|" /usr/mww/rutorrent/conf/freetz_config.php
			fi
		fi
		modlib_reload
		;;
	status)
		modlib_status
		;;
	*)
		echo "Usage: $0 [load|unload|start|stop|restart|reload|status]" 1>&2
		exit 1
		;;
esac

exit 0
